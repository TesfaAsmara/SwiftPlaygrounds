<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c6{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c7{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c3{border:1px solid black;margin:5px}.c2{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c7 doc-content"><h1 class="c6" id="h.g29n68hyors7"><span class="c5">Learn to Code 1:</span></h1><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">The Shortest Route:</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">moveForward()</span></p><p class="c0"><span class="c1">moveForward()</span></p><p class="c0"><span class="c1">moveForward()</span></p><p class="c0"><span class="c1">collectGem()</span></p><p class="c0"><span class="c1">moveForward()</span></p><p class="c0"><span class="c1">moveForward()</span></p><p class="c0"><span class="c1">moveForward()</span></p><p class="c0"><span class="c1">moveForward()</span></p><p class="c0"><span>toggleSwitch()</span><sup><a href="#cmnt1" id="cmnt_ref1">[a]</a></sup></p><hr style="page-break-before:always;display:none;"><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>Treasure Hunt:</span><sup><a href="#cmnt2" id="cmnt_ref2">[b]</a></sup></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">var toggleCounter = 0</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">func moveThenToggle() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; toggleSwitch()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; toggleCounter+=1</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">func turnAround() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">//This function solves for the simpler, paired pattern of the puzzle while utilizing toggleCounter to know when to move left to solve the other pattern.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">func solvePattern1() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveThenToggle()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; turnAround()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveForward()</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c1">if toggleCounter == 2 {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span>&nbsp; &nbsp; }</span><sup><a href="#cmnt3" id="cmnt_ref3">[c]</a></sup></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">//This function solves for the more complex, paired pattern of the puzzle while utilizing toggleCounter to know when to turn and move to solve the other pair.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">func solvePattern2() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveThenToggle()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveThenToggle()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if toggleCounter &lt; 6 {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnAround()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; move(distance:4)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">} &nbsp;</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">func move(distance:Int) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; for i in 1 ... distance {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">solvePattern1()</span></p><p class="c0"><span class="c1">solvePattern1()</span></p><p class="c0"><span class="c1">solvePattern2()</span></p><p class="c0"><span>solvePattern2()</span><sup><a href="#cmnt4" id="cmnt_ref4">[d]</a></sup></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>Four Stash Sweep:</span><sup><a href="#cmnt5" id="cmnt_ref5">[e]</a></sup></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">//Utilized when moving forward and collecting gems multiple times, then turns around.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">func moveAndCollect(numberOfTimes: Int) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; for i in 1 ... numberOfTimes {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; collectGem()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">//A reusable function that solves the repeated patterns in the puzzle.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">func solvePattern() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveAndCollect(numberOfTimes: 2)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; turnRight()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveAndCollect(numberOfTimes: 1)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; collectGem()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if isBlocked != true {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">for i in 1 ... 4 {</span></p><p class="c0"><span>&nbsp; &nbsp; solvePattern()</span><sup><a href="#cmnt6" id="cmnt_ref6">[f]</a></sup></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">Decision Tree:</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">func move(distance: Int) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; for i in 1 ... distance {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">var gemCounter = 0</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">//Solves pattern on the right side.</span></p><p class="c0"><span class="c1">func solveRightSide() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; collectGem()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; gemCounter+=1</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; turnRight()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; move(distance: 3)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; collectGem()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; gemCounter+=1</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; turnRight()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; move(distance: 3)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; turnRight()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">//Solves pattern on the left, ensures &quot;game over&quot; after all gems have been collected.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">func solveLeftSide() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; toggleSwitch()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; collectGem()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; gemCounter+=1</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if gemCounter &lt; 6{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if isOnGem {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; solveRightSide()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; } else if isOnClosedSwitch {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; solveLeftSide()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">Logical Labyrinth:</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">var gemCounter = 0</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>//Solves pattern on the right, ensures a &quot;game over&quot; at 7 gems.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">func solveRight() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; turnRight()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; collectGem()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; gemCounter+=1</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if gemCounter&lt;7 {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnRight()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">//Solves for each specific condition, checking at 8 checkpoints.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>for i in 1 ... 8 {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if isOnGem &amp;&amp; isOnClosedSwitch {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; collectGem()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; gemCounter+=1</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; toggleSwitch()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; solveRight()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; } else if isOnGem {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; collectGem()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; gemCounter+=1</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; } else if isOnClosedSwitch {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; toggleSwitch()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">You&rsquo;re Always Right:</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">while !isBlocked {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if isOnClosedSwitch {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; toggleSwitch()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp;</span><span class="c1">&nbsp;if isBlocked &amp;&amp; !isBlockedRight {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; turnRight()</span><sup><a href="#cmnt7" id="cmnt_ref7">[g]</a></sup></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if isOnGem {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; collectGem()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">Roll Right, Roll Left:</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span>while &nbsp;!isBlocked {</span><sup><a href="#cmnt8" id="cmnt_ref8">[h]</a></sup></p><p class="c0"><span class="c1">&nbsp; &nbsp; if !isOnGem || !isOnOpenSwitch {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if isBlocked &amp;&amp; isBlockedLeft &amp;&amp; !isBlockedRight {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnRight()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if isBlocked &amp;&amp; isBlockedRight &amp;&amp; !isBlockedLeft {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if isBlocked &amp;&amp; !isBlockedRight &amp;&amp; &nbsp;!isBlockedLeft {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if isOnGem {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; collectGem()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if isOnClosedSwitch {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; toggleSwitch()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c2"><span class="c1"></span></p><h1 class="c6" id="h.w2d8qgos6uts"><span class="c5">Learn to Code 2</span></h1><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">Collect The Total:</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">let totalGems = randomNumberOfGems</span></p><p class="c0"><span class="c1">var gemCounter = 0</span></p><p class="c0"><span class="c1">while gemCounter != totalGems {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if isOnGem {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; collectGem()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; gemCounter += 1 </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span>if isBlocked &amp;&amp; isBlockedRight &amp;&amp; isBlockedLeft</span><sup><a href="#cmnt9" id="cmnt_ref9">[i]</a></sup><sup><a href="#cmnt10" id="cmnt_ref10">[j]</a></sup><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if isBlocked &amp;&amp; isBlockedLeft &amp;&amp; !isBlockedRight {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnRight()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if isBlocked &amp;&amp; isBlockedRight &amp;&amp; !isBlockedLeft{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>Random Gems Everywhere:</span><sup><a href="#cmnt11" id="cmnt_ref11">[k]</a></sup><sup><a href="#cmnt12" id="cmnt_ref12">[l]</a></sup><sup><a href="#cmnt13" id="cmnt_ref13">[m]</a></sup></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; let totalGems = randomNumberOfGems</span></p><p class="c0"><span class="c1">var gemCounter = 0</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">//If blue portal is on, turns it off and vice versa</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>func </span><span>bluePortalSwitch()</span><sup><a href="#cmnt14" id="cmnt_ref14">[n]</a></sup><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if bluePortal.isActive==true {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; bluePortal.isActive=false</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; } else if bluePortal.isActive==false {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; bluePortal.isActive=true</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">//If pink portal is on, turns it off and vice versa</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">func pinkPortalSwitch() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if pinkPortal.isActive==true {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pinkPortal.isActive=false</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; } else if pinkPortal.isActive==false {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pinkPortal.isActive=true</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span>while gemCounter&lt;totalGems</span><sup><a href="#cmnt15" id="cmnt_ref15">[o]</a></sup><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if isOnGem {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; collectGem()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; gemCounter+=1</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; //Switches the portals on or off after turning around based on previous state</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if isBlocked&amp;&amp;isBlockedRight {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; bluePortalSwitch()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pinkPortalSwitch()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if isBlocked &amp;&amp; !isBlockedRight {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pinkPortalSwitch()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; bluePortalSwitch()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">It Takes Two:</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">func expertSolveGem () {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; expert.turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; while expert.isBlockedRight {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; expert.moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; expert.turnRight()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; expert.moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; expert.moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; expert.turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; expert.turnLockDown() </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; expert.turnLockDown()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">func expertSolveSwitch() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; expert.turnRight()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; expert.moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; expert.moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; expert.turnRight()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; expert.moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; while expert.isBlockedRight {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; expert.moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; expert.turnRight()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; expert.moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; expert.moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; expert.turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; expert.turnLockUp()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">func characterSolveGem() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; character.moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; character.moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; character.collectGem()</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">func characterSolveSwitch() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; character.moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; character.moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; character.toggleSwitch()</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>expertSolveGem()</span><sup><a href="#cmnt16" id="cmnt_ref16">[p]</a></sup></p><p class="c0"><span class="c1">characterSolveGem()</span></p><p class="c0"><span class="c1">expertSolveSwitch()</span></p><p class="c0"><span class="c1">characterSolveSwitch()</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>Twin Peaks:</span><sup><a href="#cmnt17" id="cmnt_ref17">[q]</a></sup></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">let a=Character()</span></p><p class="c0"><span class="c1">let b=Character()</span></p><p class="c0"><span class="c1">let c=Character()</span></p><p class="c0"><span class="c1">world.place(a, facing: .north, atColumn: 2, row: 0)</span></p><p class="c0"><span class="c1">world.place(b, facing: .north, atColumn: 3, row: 0)</span></p><p class="c0"><span class="c1">world.place(c, facing: .north, atColumn: 4, row: 0)</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">var gemCounter = 0</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>func characterNavigate(a:Character) {</span><sup><a href="#cmnt18" id="cmnt_ref18">[r]</a></sup></p><p class="c0"><span class="c1">&nbsp; &nbsp; for i in 1 ... 6 {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; if a.isOnGem {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a.collectGem()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gemCounter+=1</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a.jump()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; } else {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a.jump()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; a.turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; a.turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">while gemCounter&lt;totalGems {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; characterNavigate(a: a)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; characterNavigate(a: b)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; characterNavigate(a: c)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span>}</span></p><hr style="page-break-before:always;display:none;"><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">Build a Loop:</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">let character=Character()</span></p><p class="c0"><span class="c1">let block1=Block()</span></p><p class="c0"><span class="c1">let block2=Block()</span></p><p class="c0"><span class="c1">let redPortal=Portal(color:#colorLiteral(red: 0.9254902005195618, green: 0.23529411852359772, blue: 0.10196078568696976, alpha: 1.0))</span></p><p class="c0"><span class="c1">world.place(character, facing: .south, atColumn: 0, row: 1)</span></p><p class="c0"><span class="c1">world.place(block1, atColumn: 1, row: 3)</span></p><p class="c0"><span class="c1">world.place(block2, atColumn: 3, row: 3)</span></p><p class="c0"><span class="c1">world.place(redPortal, atStartColumn: 2, startRow: 3, atEndColumn: 7, endRow: 3)</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">var gemCounter=0</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">func navigate() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if character.isOnGem {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; character.collectGem()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; gemCounter+=1</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if character.isBlocked &amp;&amp; character.isBlockedRight==false &amp;&amp; character.isBlockedLeft==false {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; character.turnRight()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if character.isBlocked &amp;&amp; character.isBlockedRight {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; character.turnLeft()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if character.isBlockedLeft &amp;&amp; character.isBlocked {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; character.turnRight()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; character.moveForward()</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>while gemCounter&lt;totalGems {</span><sup><a href="#cmnt19" id="cmnt_ref19">[s]</a></sup></p><p class="c0"><span class="c1">&nbsp; &nbsp; navigate()</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">Fixing Index Out of Range Errors:</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">var teamBlu: [Character] = []</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">// Note how many instances of Blu are in your array.</span></p><p class="c0"><span class="c1">for i in 1...9 {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; teamBlu.append(Character(name: .blu))</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">// Place Blu at each column in row 4.</span></p><p class="c0"><span class="c1">var columnPlacement = 0</span></p><p class="c0"><span class="c1">for blu in teamBlu {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; world.place(blu, at: Coordinate(column: columnPlacement, row: 4))</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; columnPlacement += 1</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>// Find the index out of range error.</span><sup><a href="#cmnt20" id="cmnt_ref20">[t]</a></sup></p><p class="c0"><span class="c1">teamBlu[0].jump()</span></p><p class="c0"><span class="c1">teamBlu[2].collectGem()</span></p><p class="c0"><span class="c1">teamBlu[4].jump()</span></p><p class="c0"><span class="c1">teamBlu[6].collectGem()</span></p><p class="c0"><span class="c1">teamBlu[8].jump()</span></p><p class="c0 c2"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>A Puzzle of Your Own:</span><sup><a href="#cmnt21" id="cmnt_ref21">[u]</a></sup></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">let character = Character()</span></p><p class="c0"><span class="c1">let block1 = Block()</span></p><p class="c0"><span class="c1">let stair1 = Stair()</span></p><p class="c0"><span class="c1">let gem1 = Gem()</span></p><p class="c0"><span class="c1">let switch1 = Switch()</span></p><p class="c0"><span class="c1">let yellowPortal = Portal(color: #colorLiteral(red: 0.9686274528503418, green: 0.7803921699523926, blue: 0.3450980484485626, alpha: 1.0))</span></p><p class="c0"><span class="c1">var gemCounter = 0</span></p><p class="c0"><span class="c1">world.place(character, facing: .west, atColumn: 6, row: 2)</span></p><p class="c0"><span class="c1">world.place(block1, atColumn: 5, row: 2)</span></p><p class="c0"><span class="c1">world.place(stair1, facing: .west, atColumn: 4, row: 2)</span></p><p class="c0"><span class="c1">world.place(yellowPortal, atStartColumn: 3, startRow: 2, atEndColumn: 1, endRow: 2)</span></p><p class="c0"><span class="c1">world.place(gem1, atColumn: 0, row: 2)</span></p><p class="c0"><span class="c1">world.place(switch1, atColumn: 0, row: 2)</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">func navigate() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; while gemCounter&lt;1 {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; if character.isBlocked {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; character.jump()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; if character.isOnGem {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; character.collectGem()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gemCounter+=1</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; if character.isOnClosedSwitch {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; character.toggleSwitch()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; character.moveForward()</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>navigate()</span><sup><a href="#cmnt22" id="cmnt_ref22">[v]</a></sup></p><p class="c0 c2"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>World Creation:</span><sup><a href="#cmnt23" id="cmnt_ref23">[w]</a></sup></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">let insideSquare = world.coordinates(inColumns: [4,5], intersectingRows : [4,5])</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>for coor in insideSquare</span><sup><a href="#cmnt24" id="cmnt_ref24">[x]</a></sup><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; for i in 1 ... 5 {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; world.place(Block(), at: coor)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; world.place(Character(name: .byte), at: coor)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><div class="c3"><p class="c4"><a href="#cmnt_ref1" id="cmnt1">[a]</a><span class="c1">Good solution. Shortest path.</span></p><p class="c4"><span class="c1">Grade 3 (of 4) - A- All goals met.</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref2" id="cmnt2">[b]</a><span class="c1">I can see how this one can be made more efficient. In trying to make the code more reusable, I became lazy by using toggleRow() for all sides of the puzzle leading to my character having to turnAround() inefficiently on the longer rows. Thus, I should&rsquo;ve had two different &ldquo;toggleRow()&rdquo;&rsquo;s, one for each of the two pairs of rows.</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref3" id="cmnt3">[c]</a><span class="c1">This kind of embedded logic is kind of dangerous normally and you want to cover in your commenting. Why turnLeft() at toggleCounter ==2?</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref4" id="cmnt4">[d]</a><span class="c1">Good use of advanced tools (and clearly functions - which was the lesson for this exercise).</span></p><p class="c4 c2"><span class="c1"></span></p><p class="c4"><span class="c1">Grade: 4 (of 4). Normally I would ding you for the commenting which doesn&#39;t cover the stuff that one would really scratch their head with (what are you using toggle counter for, why the seemingly arbitrary ifs) but you did a good job with calling functions even with parameters.</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref5" id="cmnt5">[e]</a><span class="c1">Relatively smooth, although my character goes through the falling animation as a result of an extra moveForward(). I assume this could&rsquo;ve been prevented by breaking up my function into multiple functions.</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref6" id="cmnt6">[f]</a><span class="c1">Good solution. As you pointed out, your character falls off at the end but now you solved with an isBlocked (good place for a comment?)</span></p><p class="c4"><span class="c1">Grade 3 (of 4). Comments are a little generic, which isn&#39;t all that useful - how about the key insights?</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref7" id="cmnt7">[g]</a><span class="c1">This results in an extra turn at the end but that&#39;s ok, you don&#39;t fall off. Comment would have been good here but pretty simple code.</span></p><p class="c4"><span class="c1">Grade 3 of 4</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref8" id="cmnt8">[h]</a><span class="c1">Good solution - simple and nice use of conditionals. No comments?</span></p><p class="c4 c2"><span class="c1"></span></p><p class="c4"><span class="c1">Grade 3 of 4</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref9" id="cmnt9">[i]</a><span class="c1">These are great use of conditional logic. Would be optimum if you put in a comment, super simple one but help the reader just a bit.</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref10" id="cmnt10">[j]</a><span class="c1">Grade 3 of 4</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref11" id="cmnt11">[k]</a><span class="c1">I was stumped on how to approach the portals in this lesson and so I got some outside help.</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref12" id="cmnt12">[l]</a><span class="c1">I&#39;m curious - what outside help?</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref13" id="cmnt13">[m]</a><span class="c1">I went on YouTube, searched &ldquo;swift playground random gems everywhere tutorial&rdquo;, and I saw that, though with some variations in code- e.g. using a moveCounter variable, etc- most of the codes shared the portal code that I utilized. I was arrogant in not swallowing my pride and asking for help, especially with the quick access to information provided by YouTube. I understand that hitting walls, asking for help, and trying multiple solutions will be a part of the course, yet, with the LTC program being designed to get ahead on coding for the next year and personal learning, I wasn&rsquo;t thinking about the consequences of plagiarism, which I&rsquo;ve only heard rumors of in coding. The rest of the navigating code, such as the if statements and making it so that the functions alternated between true and false as needed, was of my own intuition, but the actual code in the portal functions wasn&rsquo;t. I hope this clears things up.</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref14" id="cmnt14">[n]</a><span class="c1">You basically wrote a inbuilt swift function called toggle. bluePortal.IsActive.toggle() would do exactly what you wrote - which is fine.</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref15" id="cmnt15">[o]</a><span class="c1">Good approach. Do you think both if isBlocked &amp;&amp; statements are necessary? how about just one with isBlocked?</span></p><p class="c4 c2"><span class="c1"></span></p><p class="c4"><span class="c1">Grade 3 (of 4). Good comments, good solution. Extra logic.</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref16" id="cmnt16">[p]</a><span class="c1">Good job. All conditions met</span></p><p class="c4"><span class="c1">Grade 3 of 4</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref17" id="cmnt17">[q]</a><span class="c1">I took an unconventional route to solving this puzzle, but I validated my use of three characters because initialization is a part of &ldquo;all of [my] coding skills&rdquo; as stated in the instructions.</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref18" id="cmnt18">[r]</a><span class="c1">Nice job!</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref19" id="cmnt19">[s]</a><span class="c1">Good job. Zero comments. Why the block placement and Portal placement (which was cool, BTW)?</span></p><p class="c4"><span class="c1">Grade 3 of 4</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref20" id="cmnt20">[t]</a><span class="c1">Fine.</span></p><p class="c4"><span class="c1">No comments (just a simple one of deleting or fixing the out of range element)</span></p><p class="c4"><span class="c1">Grade 3 of 4</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref21" id="cmnt21">[u]</a><span class="c1">Nothing special, yet fulfills the challenge requirements.</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref22" id="cmnt22">[v]</a><span class="c1">It&#39;s a fine solution. Zero comments.</span></p><p class="c4"><span class="c1">Grade 3 of 4</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref23" id="cmnt23">[w]</a><span class="c1">Also nothing special, I simply completed the first prompt.</span></p></div><div class="c3"><p class="c4"><a href="#cmnt_ref24" id="cmnt24">[x]</a><span class="c1">Seriously? That&#39;s a bit of a joke.</span></p><p class="c4"><span class="c1">Grade 2 of 4</span></p></div></body></html>